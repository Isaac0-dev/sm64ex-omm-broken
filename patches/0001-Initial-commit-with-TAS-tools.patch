From 3c1776d5d861e3c184a4543f291e75099c48216f Mon Sep 17 00:00:00 2001
From: Isaac0-dev <62234577+Isaac0-dev@users.noreply.github.com>
Date: Tue, 21 Mar 2023 15:09:11 +1000
Subject: [PATCH] Initial commit with TAS tools

---
 data/omm/engine/controller_keyboard.c       | 16 +++++++
 data/omm/engine/controller_sdl.c            | 21 +++++++++
 data/omm/engine/controller_tas.c            | 41 +++++++++++++++++
 src/pc/cliopts.c                            | 16 ++++++-
 src/pc/cliopts.h                            |  9 ++++
 src/pc/controller/controller_recorded_tas.c | 32 +++++++++++---
 src/pc/pc_main.c                            | 49 ++++++++++++++++++++-
 7 files changed, 176 insertions(+), 8 deletions(-)
 create mode 100644 data/omm/engine/controller_tas.c

diff --git a/data/omm/engine/controller_keyboard.c b/data/omm/engine/controller_keyboard.c
index aa0a6ca..1e6f288 100644
--- a/data/omm/engine/controller_keyboard.c
+++ b/data/omm/engine/controller_keyboard.c
@@ -10,6 +10,12 @@ static OmmArray sKeyboardMapping = omm_array_zero;
 static u32 sKeyboardDownMask = 0;
 static u32 sKeyboardLastKey = VK_INVALID;
 
+void tas_shutdown(void);
+void tas_record(OSContPad *pad);
+void tas_init(void);
+
+bool is_controller_active(void);
+
 //
 // Keyboard API
 //
@@ -50,6 +56,9 @@ static void keyboard_bindkeys(void) {
 
 static void keyboard_init(void) {
     keyboard_bindkeys();
+    if (gTas.controllerType == 1 && gTas.onStart == 1) {
+        tas_init();
+    }
 }
 
 static void keyboard_read(OSContPad *pad) {
@@ -63,6 +72,10 @@ static void keyboard_read(OSContPad *pad) {
         case STICK_DOWN:  pad->stick_y = -0x7F; break;
         case STICK_UP:    pad->stick_y = +0x7F; break;
     }
+
+    if (gTas.controllerType == 1) {
+        tas_record(pad);
+    }
 }
 
 static u32 keyboard_rawkey(void) {
@@ -72,6 +85,9 @@ static u32 keyboard_rawkey(void) {
 }
 
 static void keyboard_shutdown(void) {
+    if (gTas.controllerType == 1) {
+        tas_shutdown();
+    }
 }
 
 struct ControllerAPI controller_keyboard = {
diff --git a/data/omm/engine/controller_sdl.c b/data/omm/engine/controller_sdl.c
index 6ad24a9..b8fef4e 100644
--- a/data/omm/engine/controller_sdl.c
+++ b/data/omm/engine/controller_sdl.c
@@ -21,6 +21,17 @@ static SDL_GameController *sController;
 s32 gMouseHasFreeControl = FALSE;
 s32 gMouseHasCenterControl = FALSE;
 
+void tas_shutdown(void);
+void tas_record(OSContPad *pad);
+void tas_init(void);
+
+bool is_controller_active(void) {
+    if (OMM_LIKELY(sControllerInited) && sController) {
+        return true;
+    }
+    return false;
+}
+
 //
 // Joystick
 //
@@ -97,6 +108,9 @@ static void controller_sdl_init(void) {
     controller_sdl_bind();
     controller_sdl_get_mouse_state();
     sControllerInited = true;
+    if (gTas.controllerType == 2) {
+        tas_init();
+    }
 }
 
 static void controller_sdl_read(OSContPad *pad) {
@@ -187,6 +201,10 @@ static void controller_sdl_read(OSContPad *pad) {
             case STICK_DOWN:  pad->stick_y = -0x7F; break;
             case STICK_UP:    pad->stick_y = +0x7F; break;
         }
+
+        if (gTas.controllerType == 2) {
+            tas_record(pad);
+        }
     }
 }
 
@@ -213,6 +231,9 @@ static void controller_sdl_shutdown(void) {
             sController = NULL;
         }
         SDL_QuitSubSystem(SDL_INIT_GAMECONTROLLER);
+        if (gTas.controllerType == 2) {
+            tas_shutdown();
+        }
     }
     sControllerInited = false;
 }
diff --git a/data/omm/engine/controller_tas.c b/data/omm/engine/controller_tas.c
new file mode 100644
index 0000000..ef3b158
--- /dev/null
+++ b/data/omm/engine/controller_tas.c
@@ -0,0 +1,41 @@
+#define OMM_ALL_HEADERS
+#include "data/omm/omm_includes.h"
+#undef OMM_ALL_HEADERS
+
+static FILE *fp;
+
+void tas_shutdown(void) {
+    if (fp != NULL) {
+        fclose(fp);
+        fp = NULL;
+        printf("CLOSED\n");
+    }
+}
+
+void tas_record(OSContPad *pad) {
+    if (fp != NULL) {
+        uint8_t bytes[5] = {0};
+        bytes[0] = (pad->button >> 8);
+        bytes[1] = pad->button;
+        bytes[2] = pad->stick_x;
+        bytes[3] = pad->stick_y;
+        bytes[4] = gOmmMario->spin.pressed;
+
+        fwrite(bytes, 1, 5, fp);
+        printf("WROTE %d\n", bytes[0]);
+    }
+}
+
+void tas_init(void) {
+    fp = fopen("cont.m64", "rb");
+    if (fp == NULL) {
+        fp = fopen("write.m64", "wb");
+        if (fp != NULL) {
+            uint8_t buf[0x400];
+            fwrite(buf, 1, sizeof(buf), fp);
+        }
+    } else {
+        fclose(fp);
+        fp = NULL;
+    }
+}
diff --git a/src/pc/cliopts.c b/src/pc/cliopts.c
index b01ef68..f8097db 100644
--- a/src/pc/cliopts.c
+++ b/src/pc/cliopts.c
@@ -12,6 +12,7 @@
 #include <string.h>
 
 struct PCCLIOptions gCLIOpts;
+struct Tas gTas;
 
 static void print_help(void) {
     printf("Super Mario 64 PC Port\n");
@@ -22,6 +23,7 @@ static void print_help(void) {
     printf("%-20s\tStarts the game in full screen mode.\n", "--fullscreen");
     printf("%-20s\tSkips the Peach and Castle intro when starting a new game.\n", "--skip-intro");
     printf("%-20s\tStarts the game in windowed mode.\n", "--windowed");
+    printf("%-20s\tStarts the game with tas recording enabled. Parameters should be 1 (sets the recorded controller type to a contoller) or 0 (sets the controller type to keyboard).\n", "--tas");
 }
 
 static inline int arg_string(const char *name, const char *value, char *target) {
@@ -70,8 +72,20 @@ void parse_cli_opts(int argc, char* argv[]) {
         else if (strcmp(argv[i], "--savepath") == 0 && (i + 1) < argc)
             arg_string("--savepath", argv[++i], gCLIOpts.SavePath);
 
+        else if (strcmp(argv[i], "--tas") == 0 && (((i + 1) < argc) || ((i + 2) < argc))) {
+            arg_uint("--tas <type>", argv[++i], &gTas.controllerType);
+            if (gTas.controllerType > 2 || gTas.controllerType < 0) {
+                printf("controller type can only be 1 or 2\n");
+                game_exit();
+                return;
+            }
+            if ((i + 2) == argc) {
+                arg_uint("--tas <onStart>", argv[++i], &gTas.onStart);
+            } else {
+                gTas.onStart = 1;
+            }
         // Print help
-        else if (strcmp(argv[i], "--help") == 0) {
+        } else if (strcmp(argv[i], "--help") == 0) {
             print_help();
             game_exit();
         }
diff --git a/src/pc/cliopts.h b/src/pc/cliopts.h
index a0281e2..a3f6bd4 100644
--- a/src/pc/cliopts.h
+++ b/src/pc/cliopts.h
@@ -14,6 +14,15 @@ struct PCCLIOptions  {
 
 extern struct PCCLIOptions gCLIOpts;
 
+struct Tas {
+    unsigned int controllerType;
+    unsigned int stop;
+    unsigned int progress;
+    unsigned int onStart;
+};
+
+extern struct Tas gTas;
+
 void parse_cli_opts(int argc, char* argv[]);
 
 #endif // _CLIOPTS_H
diff --git a/src/pc/controller/controller_recorded_tas.c b/src/pc/controller/controller_recorded_tas.c
index 73b507d..9b9e037 100644
--- a/src/pc/controller/controller_recorded_tas.c
+++ b/src/pc/controller/controller_recorded_tas.c
@@ -1,6 +1,10 @@
 #include <stdio.h>
 #include <ultra64.h>
 
+#define OMM_ALL_HEADERS
+#include "data/omm/omm_includes.h"
+#undef OMM_ALL_HEADERS
+
 #include "controller_api.h"
 
 static FILE *fp;
@@ -13,14 +17,13 @@ static void tas_init(void) {
     }
 }
 
-static void tas_read(OSContPad *pad) {
+FILE *tas_init_off_start(void) {
+    fp = fopen("singleStar.m64", "rb");
     if (fp != NULL) {
-        uint8_t bytes[4] = {0};
-        fread(bytes, 1, 4, fp);
-        pad->button = (bytes[0] << 8) | bytes[1];
-        pad->stick_x = bytes[2];
-        pad->stick_y = bytes[3];
+        uint8_t buf[0x400];
+        fread(buf, 1, sizeof(buf), fp);
     }
+    return fp;
 }
 
 static void tas_shutdown(void) {
@@ -30,6 +33,23 @@ static void tas_shutdown(void) {
     }
 }
 
+static void tas_read(OSContPad *pad) {
+    if (fp != NULL) {
+        uint8_t bytes[5] = {0};
+        fread(bytes, 1, 5, fp);
+        pad->button = (bytes[0] << 8) | bytes[1];
+        pad->stick_x = bytes[2];
+        pad->stick_y = bytes[3];
+        gOmmMario->spin.pressed = bytes[4];
+
+        printf("READ %d\n", bytes[0]);
+        if (feof(fp)) {
+            printf("END OF FILE\n");
+            tas_shutdown();
+        }
+    }
+}
+
 static u32 tas_rawkey(void) {
     return VK_INVALID;
 }
diff --git a/src/pc/pc_main.c b/src/pc/pc_main.c
index 923e7ea..c6bbe5b 100644
--- a/src/pc/pc_main.c
+++ b/src/pc/pc_main.c
@@ -83,6 +83,13 @@ void send_display_list(struct SPTask *spTask) {
 #define SAMPLES_LOW 528
 #endif
 
+bool holdingTab = false;
+bool holdingReturn = false;
+bool holdingBackspace = false;
+
+void tas_init(void);
+FILE *tas_init_off_start(void);
+
 void produce_one_frame(void) {
     gfx_start_frame();
 
@@ -91,7 +98,44 @@ void produce_one_frame(void) {
     set_sequence_player_volume(SEQ_PLAYER_SFX, (f32)configSfxVolume / 127.0f * master_mod);
     set_sequence_player_volume(SEQ_PLAYER_ENV, (f32)configEnvVolume / 127.0f * master_mod);
 
-    game_loop_one_iteration();
+    const u8 *state = SDL_GetKeyboardState(NULL);
+    if (state[SDL_SCANCODE_RETURN] && !holdingReturn) {
+        if (gTas.stop == 1) {
+            gTas.stop = 0;
+        } else {
+            gTas.stop = 1;
+        }
+        holdingReturn = true;
+    } else {
+        holdingReturn = false;
+    }
+
+    if (state[SDL_SCANCODE_BACKSPACE] && !holdingBackspace && gTas.onStart == 0 && gTas.controllerType != 0) {
+        tas_init();
+        holdingBackspace = true;
+    } else if (state[SDL_SCANCODE_BACKSPACE] && !holdingBackspace && gTas.onStart == 0) {
+        tas_init_off_start();
+        holdingBackspace = true;
+    } else {
+        holdingBackspace = false;
+    }
+
+    if ((state[SDL_SCANCODE_TAB] || SDL_GetMouseState(NULL, NULL) & SDL_BUTTON(SDL_BUTTON_LEFT)) && !holdingTab) {
+        if (gTas.progress == 1) {
+            gTas.progress = 0;
+        } else {
+            gTas.progress = 1;
+        }
+        holdingTab = true;
+    } else {
+        holdingTab = false;
+    }
+
+    if ((!gTas.stop && gTas.progress) || (gTas.stop && gTas.progress)) {
+        game_loop_one_iteration();
+        gTas.progress = 0;
+    }
+    if (!gTas.stop) { gTas.progress = 1; }
     thread6_rumble_loop(NULL);
 
     int samples_left = audio_api->buffered();
@@ -221,6 +265,9 @@ void main_func(void) {
     #endif
     ;
 
+    gTas.stop = 0;
+    gTas.progress = 1;
+
     gfx_init(wm_api, rendering_api, window_title);
     wm_api->set_keyboard_callbacks(keyboard_on_key_down, keyboard_on_key_up, keyboard_on_all_keys_up);
 
-- 
2.39.2

